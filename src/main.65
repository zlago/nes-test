; - le main file -
; if something doesnt deserve
; its own file i throw it here
; sometimes i forget to do that though

.include "nes.i" ; hardware definitions
.include "nes2header.i" ; header definition macros
.include "main.imp" ; import used labels
; define the header
nes2mapper 0 ; NROM
nes2prg 16384 ; 16K PRG
nes2chr 8192 ; 8K CHR
nes2mirror 'H' ; horizontal mirroring
nes2tv 'N' ; NTSC only
nes2end

.segment "ZEROPAGE"
zNMI: .res 1 ; set by NMI
zColor: .res 1

.segment "VECTORS"
; define the interrpt/reset vectors
.word NMI ; NMI vector
.word Start ; reset vector
.word IRQ ; IRQ vector

.segment "CODE"
; execution starts here
Start:
	; enable NMIs and +32
	lda #CTRLF_NMI | CTRLF_INC32
	sta PPUCTRL
	; blank and tint to make it a bit easier on the eyes
	lda #MASKF_R | MASKF_G | MASKF_B
	sta PPUMASK
	; init zColor and zNMI
	lda #$21-1
	sta zColor
	lda #00
	sta zNMI
Spin: ; spin till nmi flag set
	ldx #6 ; extra delay
@Loop: ; the actual waitloop
	lda zNMI ; poll nmi flag
	beq @Loop
	lda #$00 ; reset nmi flag
	sta zNMI
	dex ; delay writes so its easier on the eyes
	bne @Loop
Color: ; do funny math on palette
	; read buttons
	jsr PollPads
	; read, idk
	lda zPad1
	; select address
	lda PPUSTATUS ; reset latch
	lda #$3f ; MSB of palette addr
	sta PPUADDR
	lda #$00 ; LSB of palette addr
	sta PPUADDR
	; prep data
	inc zColor
	lda zColor
	sta PPUDATA ; load color
	; loop palette cycle if needed
	cmp #$2d-1
	bcc Spin
	lda #$21-1
	sta zColor
	; done
	jmp Spin
	
.segment "CODE"
; interrupt
IRQ:
	rti

.segment "CODE"
; non-maskable interrupt
NMI:
	pha
	lda PPUSTATUS ; reset vblank flag
	inc zNMI ; increment nmi flag
	pla
	rti

.segment "CHR"
.incbin "res/fuckdisshit.chr" ; literally required